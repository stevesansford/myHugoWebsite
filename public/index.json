[{"content":"","date":null,"permalink":"uild/tags/%23100dayaofcoding/","section":"Tags","summary":"","title":"#100DayaOfCoding"},{"content":"My plan for today was to create a performance test module for ZonePy. I thought it would be neat if there was a module built into the program triggered by a command line flag. When activated, it would run through a list of provided domains and benchmark the time taken to resolve the domain name.\nI wasn\u0026rsquo;t too far into the testing process when I realized I made a big mistake with my order of operations in the main program. I kept noticing cached records for root servers and name servers.\nThis is rather pointless. Why have a cache if you process every domain name recursively anyway?\nUpon further investigation, I discovered that while the cache was being used, it was being used as part of the recursive search. This means ZonePy was decoding the DNS request, finding the domain needed, and then launching into its recursive search process, whereupon it began to check the local cache before making an upstream request.\nThis is rather pointless. Why have a cache if you process every domain name recursively anyway?\nOrder of Operations Matters #The issue is that I need the program to check the cache earlier. As soon as the DNS request is decoded and we know the domain that was asked for, ZonePy needs to check the cache immediately and return any unexpected IP address that it has stored.\nI reworked the order of the program\u0026rsquo;s functions. It wasn\u0026rsquo;t a complicated process. I changed the code to include the cache check in the main program loop.\nThis is the corrected code:\nwhile True: # listen for incoming requests data, addr = sock.recvfrom(512) # receive DNS request from client start_time = time.perf_counter() # start the clock logging.debug(f\u0026#34;DNS request received from {addr[0]}\u0026#34;) header, question = parse_client_request_packet(data) # parse client DNS request logging.debug(f\u0026#34;Checking cache for {question.name}\u0026#34;) if cached_record := check_cache(question.name, question.type_): response = create_return_packet(header, question, cached_record[0], cached_record[1]) elapsed_time = round((time.perf_counter() - start_time) * 1000) logging.info(f\u0026#34;Cached record found for {question.name} in {elapsed_time}ms\u0026#34;) else: logging.debug(f\u0026#34;No Cached record found for {question.name}\u0026#34;) resolved_record = resolve(question.name, question.type_) Now, ZonePy will check the local cache as soon as it knows what domain has been requested. The IP address for a cached domain is now returned within 1-3ms. A significant performance improvement already covers the 400-600ms it was taking before, as every call was resolved recursively, with a cache check at each hop.\nI\u0026rsquo;ll revisit an optimized cache solution in the future.\nI\u0026rsquo;m not sure how I got that mixed up, but the main thing is it\u0026rsquo;s fixed now. I still want to explore other caching options besides a simple text file, but there are many more important tasks that need to be completed that will have a much bigger impact on ZonePy\u0026rsquo;s performance. I\u0026rsquo;ll revisit an optimized cache solution in the future.\nNo Need to Reinvent the Wheel #Reinventing the wheel can be entertaining and educational, but I realized, in this case, it\u0026rsquo;s unnecessary. I don\u0026rsquo;t need to finish the perf test function I started. I just need to download GRC\u0026rsquo;s excellent DNS Benchmark utility, and it should give me all the information I need to dial in the performance of ZonePy.\nWhich I desperately need. Because although it\u0026rsquo;s stable enough to run as the primary DNS on my MacBook, it\u0026rsquo;s painfully slow, leading to a lot of timeouts. It is not unexpected, considering there\u0026rsquo;s no optimization like asynchronous requests., but I know I can do better.\nFortunately for me, I still have 86 more days to go\u0026hellip;\n","date":"4 January 2025","permalink":"uild/posts/coding/day-14-fixing-a-useless-dns-cache/","section":"Posts","summary":"","title":"Day #14: Fixing a Useless DNS Cache"},{"content":"","date":null,"permalink":"uild/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":null,"permalink":"uild/","section":"Steve Sansford","summary":"","title":"Steve Sansford"},{"content":"","date":null,"permalink":"uild/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"Yep. I gave it a name. ZonePy. I solved the last issue preventing me from using it as the primary DNS server for my MacBook. After it ran crash-free today for over two hours, I thought it should have a name. ChatGPT suggested a bunch, but ZonePy was my favourite (and the domain was available).\nThere\u0026rsquo;s still a long way to go and much to learn about DNS and Python, but I\u0026rsquo;m excited that I have a usable server. The issue I sorted out today was a problem where the program would hang waiting for a response from an upstream DNS server.\nFor example, if a nameserver failed to respond, the program would get stuck. That\u0026rsquo;s why most domains have multiple nameservers for redundancy. One of the limitations of ZonePY is it only processes the first record. It ignores redundancy, but I intend to make that my next project (I think).\nDealing with an Unresponsive DNS Server #I can\u0026rsquo;t say what\u0026rsquo;s causing the timeout. It could very well be my Starlink ISP. I\u0026rsquo;m still running a Gen 1 dishy, and it\u0026rsquo;s had some bumps. The motors are broken, and it\u0026rsquo;s stuck in a single orientation. There are good days and bad. I could upload my code to a cloud server (which I may do), and that might resolve the timeouts.\nI\u0026rsquo;m still running a Gen 1 dishy and it\u0026rsquo;s had some bumps. The motors are broken, and it\u0026rsquo;s stuck in a single orientation.\nRegardless, even if that is my issue, non-responsive servers are going to happen, so my program needs to have a mechanism to deal with it. I have two choices: socket.settimeout() or asyncio. For this quick fix, I went with the timeout option on socket.\nThis was the code that caused the hangup. As you can see, there is no mechanism to deal with a lack of response from the nameserver. The program just sits and waits.\nlogging.debug(f\u0026#34;Query sent to {nameserver}\u0026#34;) sock.sendto(query, (nameserver, 53)) # open connection to the nameserver response, _ = sock.recvfrom(512) I added a one-second timeout. If ZonePy doesn\u0026rsquo;t receive a response from the upstream server in under one second, it returns an NXDOMAIN. Here\u0026rsquo;s the updated code:\ntry: logging.debug(f\u0026#34;Query sent to {nameserver}\u0026#34;) sock.settimeout(1) sock.sendto(query, (nameserver, 53)) # open connection to the nameserver response, _ = sock.recvfrom(512) logging.debug(f\u0026#34;Response received from {nameserver}\u0026#34;) except socket.timeout: logging.warning(f\u0026#34;Response from {nameserver} timed out.\u0026#34;) response = None finally: sock.close() It\u0026rsquo;s a temporary solution, as my long-term plan is to make the resolver fully asynchronous so it can handle a higher volume of DNS queries. It will also asynchronously query all possible nameservers from a given record, which will also take care of an unresponsive server.\nThis step will probably come after I create a better cache. I\u0026rsquo;m looking at Redis, and even if it\u0026rsquo;s not the right choice, I\u0026rsquo;m interested in learning more about how it works. After all, that\u0026rsquo;s the point of this DNS server project. To learn programming and coding.\nI really want to rewrite this server in Haskell and Rust just for fun.\nRunning ZonePy as My Primary DNS Server #After this change was implemented, I ran ZonePy on port 53 and pointed my laptop to 127.0.0.1 for its DNS. It ran all afternoon without fault while I did all manner of work tasks. It did feel sluggish at times, but whether that\u0026rsquo;s related to my extremely un-optimized DNS server or my struggling Starlink connection, I do not know.\nBuilding a Perf-Test Module #Now that the server is functional, I\u0026rsquo;m going to build a performance test (maybe as a module in the program) so I can test the server against a list of domains and monitor resolution times. It\u0026rsquo;ll be helpful to isolate any potential ISP issues I may be having.\nIt will also let me quantify changes to the caching, asynchronous operations, hosting environments, code optimizations and probably a few other things. If I can establish a baseline by resolving a list of 1,000 or so domain names, I can get an average resolution time per domain. I don\u0026rsquo;t know if this is how the pros do it, but for my learning exercise, it\u0026rsquo;ll be sufficient for this phase of my program.\nNext Steps for the ZonePy DNS Server #In no particular order: return multiple records, improve the cache, implement asynchronous operations, add proper support for IPv6 and HTTPS records, refactor and improve the code. I\u0026rsquo;m sure there are many more things I need.\nGood thing there\u0026rsquo;s still 87 more days to go\u0026hellip;\n","date":"20 November 2024","permalink":"uild/posts/coding/day-13-meet-zonepy-a-python-powered-dns-server/","section":"Posts","summary":"","title":"Day #13: Meet ZonePy: A Python-Powered DNS Server"},{"content":"","date":null,"permalink":"uild/tags/%23100daysofcoding/","section":"Tags","summary":"","title":"#100DaysOfCoding"},{"content":"I took a much-needed break from my Python DNS server project yesterday. My coding brain needed a rest after the two-day grind. I also needed time to finish up the last couple of blog posts. That doesn\u0026rsquo;t mean I didn\u0026rsquo;t spend time thinking about the DNS server. I got back to coding again today to add a few new features.\nI did add a small bit of code yesterday to provide support for SOA records. It\u0026rsquo;s not something I would have considered, but interestingly enough, the howcode.org domain from the first server tutorial returns an SOA record when it\u0026rsquo;s recursively searched. They\u0026rsquo;re handled similarly to CNAME, so it\u0026rsquo;s a quick fix.\nMoving on From print() #Like most beginners, the first built-in function I learned was print(). It\u0026rsquo;s incredibly useful and easy to use, which is why my code to this point is littered with print() statements. I needed some way to track my way through the program. A lot is going on.\nimport logging logging.basicConfig(format=\u0026#34;{asctime} - {levelname} - {message}\u0026#34;, style=\u0026#34;{\u0026#34;, datefmt=\u0026#34;%Y-%m-%d %H:%M\u0026#34;, level=logging.INFO) It was time to switch to logging. I added the necessary import statement, built a basic format string and changed all my print() statements to some variation of logging.x() depending on the situation.\nI also added a few extra DEBUG and INFO lines to get a nice smooth output when running the program.\nUpdating the TYPE Tuple for New Record Types #When I added the SOA record yesterday to the TYPE tuple, I realized that it worked for the original record types which are indexed from 1 to 16:\nTYPE = (\u0026#39;\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;NS\u0026#39;, \u0026#39;MD\u0026#39;, \u0026#39;MF\u0026#39;, \u0026#39;CNAME\u0026#39;, \u0026#39;SOA\u0026#39;, \u0026#39;MB\u0026#39;, \u0026#39;MG\u0026#39;, \u0026#39;MR\u0026#39;, \u0026#39;NULL\u0026#39;, \u0026#39;WKS\u0026#39;, \u0026#39;PTR\u0026#39;, \u0026#39;HINFO\u0026#39;, \u0026#39;MINFO\u0026#39;, \u0026#39;MX\u0026#39;, \u0026#39;TXT\u0026#39;) But now many of those are obsolete, and I was already getting errors from AAAA and HTTPS record requests. Their indexes are 28 and 65, respectively. I would end up with a lot of blank elements in my very long tuple and with more than a few useless record types.\nTYPE = {\u0026#39;A\u0026#39;: 1, \u0026#39;NS\u0026#39;: 2, \u0026#39;CNAME\u0026#39;: 5, \u0026#39;SOA\u0026#39;: 6, \u0026#39;TXT\u0026#39;: 16, \u0026#39;AAAA\u0026#39;: 28, \u0026#39;HTTPS\u0026#39;: 65} I figured if I swapped to a dictionary, I could use a key: value pair only for the record types that I needed. It\u0026rsquo;s a much cleaner implementation. Now, I can just call the dictionary by the key (TYPE['CNAME']), and the correct integer will be returned.\nMy Almost Useable Python DNS Server #In the last exercise, Julia Evans suggests trying out the Python DNS server by pointing the DNS on your local machine to the program. That sounded like fine. Well aware that things would break, I thought, what better way to test my new DNS server than to start using it to resolve real DNS requests?\nI changed the SERVER_PORT variable to 53 (standard DNS port) and adjusted my DNS settings on my MacBook to point to 127.0.0.1.\nI then spent the next three hours chasing down bugs and refactoring code to smooth out the process. The biggest issue I had was the original code caused the program to process some CNAME records as NS records in situations where there is a CNAME record in the answers section and an NS record in the authorities section. This mostly happened with Apple and Amazon domains. Good thing those aren\u0026rsquo;t important.\nelif cname := get_cname(response): logging.debug(f\u0026#34;Resolving [CNAME] for [{cname}]\u0026#34;) return resolve(cname, 1) elif nsIP := get_nameserver_ip(response): nameserver = nsIP elif ns_domain := get_nameserver(response): logging.debug(f\u0026#34;Resolving [NS] for [{ns_domain}]\u0026#34;) nameserver, _ = resolve(ns_domain, 1) The simple fix was to reorder the if/elif statement so that CNAME records were processed first. Full disclosure: this simple fix took me hours to find. That avoided the false positive triggered by the NS condition. So far, that has resolved the infinite loops I was experiencing.\nQuick Fix (Sort Of) for AAAA and HTTPS Requests #The other issue that broke the code quite often was requests from my MacBook IPv6 AAAA and Type 65 HTTPS requests. I now had support in my TYPE variable for these two record types, but I\u0026rsquo;m not yet ready to tackle those features. Both of those will be big tasks.\nFor now, I came up with a shortcut. There are going to be times when the resolver cannot successfully resolve an IP address. Maybe it\u0026rsquo;s invalid. Maybe there\u0026rsquo;s a network issue or some sort of filtering in place that prevents proper resolution. In those cases, a DNS server will return an RCODE = 3 in the header flags, known as an NXDOMAIN. It tells the requester that no records for this domain can be found.\nThere are going to be times when the resolver cannot successfully resolve an IP address.\nNeither AAAA nor HTTPS requests are required in any cases I am aware of. Most computers will request those records, along with a standard A record. If the AAAA and/or HTTPS requests are returned to the client with an NXDOMAIN the client will rely on the A record and establish the connection over IPv4. This is a simplification, but it\u0026rsquo;s sufficient for now.\ndef create_nx_domain_packet(dns_header, dns_question): header = struct.pack(\u0026#34;!HHHHHH\u0026#34;, dns_header.id, 0b1000010000000011, 0, 0, 0, 0) question = encode_domain_name( dns_question.name) + struct.pack(\u0026#34;!HH\u0026#34;, dns_question.type_, dns_question.class_) return header + question I created a function to return a properly formatted DNS response with a QD_COUNT equal to 0 and a header flag with 3 for the RCODE. If the response from the resolver comes back empty, which I\u0026rsquo;ve forced in the event of an AAAA or HTTPS request, the server returns the NXDOMAIN packet to the client. This prevents the program from crashing and it continues to accept and process DNS requests.\nThe DNS server is now able to function as the primary resolver for my MacBook:\n2024-11-19 20:39 - INFO - Resolved [a.gslb.aaplimg.com] to [17.253.201.8] via Local Cache 2024-11-19 20:39 - INFO - Querying [17.253.201.8] for [kt-prod.v.aaplimg.com] 2024-11-19 20:39 - INFO - Resolved [kt-prod.v.aaplimg.com] to [17.138.175.254] via Recursive Search. 2024-11-19 20:39 - INFO - Resolved [kt-prod.ess.apple.com] to [17.138.175.254] via Recursive Search. 2024-11-19 20:39 - INFO - Request processed in: 433ms 2024-11-19 20:39 - INFO - Querying [198.41.0.4] for [kt-prod.ess.apple.com] 2024-11-19 20:39 - INFO - Querying [192.41.162.30] for [kt-prod.ess.apple.com] 2024-11-19 20:39 - INFO - Querying [17.253.200.1] for [kt-prod.ess.apple.com] I Also Added a Timer #I wanted to track the time the resolver took to complete the process. I used the time.time_perf() function in Python to measure the elapsed time from when the request was received until the moment the response was sent to the client. This will allow me to track the impact on performance as I change and update the code. I wonder if Redis would be faster?\nstart_time = time.perf_counter() # attempt to resolve the client\u0026#39;s request response = resolve(dns_question.name, dns_question.type_) # record time elapsed_time = round((time.perf_counter() - start_time) * 1000) I was also pleased to see that while the recurring searches took 400 to 600ms on average, the local cache returned its records in \u0026lt; 20ms. That\u0026rsquo;s why we cache records.\nOne Last Big Hurdle to Overcome #There are probably many more than one, but I am aware of only one right now. If the DNS server sends a query to an upstream server and that connection times out, the server will crash. This is the only bug I know preventing me from using my server as DNS on my MacBook.\nI suspect there may be some solution involving asynchronous functions, but tracking down the exact issue and coming up with a resolution is a project for another day, which is fine by me.\nBecause there are still 88 more days to go\u0026hellip;\n","date":"19 November 2024","permalink":"uild/posts/coding/day-12-an-almost-useable-dns-server/","section":"Posts","summary":"","title":"Day #12: An Almost Useable DNS Server"},{"content":"","date":null,"permalink":"uild/tags/python/","section":"Tags","summary":"","title":"Python"},{"content":"This has been an excellent project for developing my coding skills. So far, I have a working DNS server that listens for incoming DNS requests and returns a response from a local zone file. I also have a DNS resolver that takes a given domain name, does a recursive search through the DNS hierarchy, returns an IP address, and caches the result for future use.\nBoth are good programs, but I need to combine the resolver and the server program so that instead of looking to a local zone file (like a nameserver), the DNS server will use its resolver to perform a proper search. Then, I\u0026rsquo;ll have a functional recursive DNS server.\nLook out 8.8.8.8!\nExercise #7: Build a DNS Server #Exercise #7 from the Implementing DNS in a Weekend webzine series I followed to build the resolver is to add server functionality. Then, instead of using a provided domain name, we can send an actual DNS query to the server and return a properly formatted DNS response to the client.\nIt was a grind. At least a ten-hour session, maybe longer. I lost track of the time. But I wasn\u0026rsquo;t able to stop, even though I could have used a break many times. I don\u0026rsquo;t recall the exact steps I followed, but I do recall many of the issues I had to overcome. The whole process culminated in a complete \u0026ldquo;re-write\u0026rdquo; near the end.\nFiguring out the Best Place to Start #I have two functioning programs. I needed to pick one to start from and incorporate the elements of the second. Adding additional functionality to the server program seemed like the logical approach. The issue is everything in the server program is encoded manually, byte by byte.\nThe resolver script, on the other hand, makes use of @dataclasses to store our DNS information. It also benefits from struct functions, which make moving strings to and from bytes much simpler than doing it manually. The functions to process the recursive search are also more complicated than anything in the server program.\nI decided it would be best to begin with the resolver and build the server functionality around it. That may not have been correct.\nStep One: Replacing the Supplied Domain with a DNS Request #It was a simple matter to use socket to create a listener on localhost:5053 for the DNS server. Then I could dig @localhost -p 5053 and the DNS query would be received by the server.\nProblem #1: The Client Sends DNS Querys as Byte Strings #It went downhill right from the beginning. The resolver assumes an input in the form of a simple string (google.com). Our client is sending a complete query as a byte string:\nb\u0026#39;K\\xdb\\x01 \\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x01\\x06google\\x03com\\x00\\x00\\x01\\x00\\x01\\x00\\x00)\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\u0026#39; I needed to parse the DNS request from the client to get the information I needed to pass to the resolver function. As the resolver already had a function to parse the response from the upstream nameserver, I thought I\u0026rsquo;d just use that.\nI\u0026rsquo;m not sure I\u0026rsquo;ve recovered from that particular mistake. Remember what I said about bad decisions? This started me down the trail of modifying all my perfectly good functions until nothing worked right, and the code base was a mess. But more on that later.\nAfter my total \u0026ldquo;re-write,\u0026rdquo; I ended up with two similar functions: parse_client_response_packet() and the original, which I renamed to parse_server_response_packet(). While similar, they process the data in different ways.\ndef parse_client_request_packet(data): reader = BytesIO(data) # allow us to iterate over the bytestring # read header bytes and unpack items = struct.unpack(\u0026#34;!HHHHHH\u0026#34;, reader.read(12)) header = DNSHeader(*items) # build header name = decode_name(reader) # read the requested URL data = reader.read(4) # read the bytes containing the type and class # format type and class for question type_, class_ = struct.unpack(\u0026#34;!HH\u0026#34;, data) # build the DNS client question question = DNSQuestion(name, type_, class_) return header, question You can also see the benefit of the struct function in Python. It\u0026rsquo;s simple to pass it a format and a byte string and have it return a list of items we can pass to our DNSHeader object for further processing. We now have populated objects with all the information sent from the client, including the domain name to pass to the resolver.\nStep Two: Resolve the Domain Name #Thanks to our function above, we now have the information we need to submit to our existing resolver function:\nip_address, ttl = resolve(dns_question.name, dns_question.type_) It requires two arguments: the domain name and the record type. Both of these are contained in our dns_question object. The resolver returns the ip_address and the ttl.\nI want to dive further into the functionality of the resolver, but I\u0026rsquo;m honestly not clear on how it worked before the rewrite. It could benefit from its own post (and maybe it\u0026rsquo;ll get one or seventeen). But I am clear on the problems I had getting it to work.\nProblems with the Resolver #It was really one problem. I was trying to pass bytes of data to functions that were designed to work with strings. It was a mess. I\u0026rsquo;d just spent the last hour or so messing them up even more, trying to parse the request byte string. My functions weren\u0026rsquo;t processing anything correctly.\nI also struggled to understand the problem with the byte strings because I couldn\u0026rsquo;t read them. I know the problem stemmed from working with DNS client/server communications in bytes but storing and manipulating the data in my data classes, which use integers and strings.\nAll the back-and-forth conversion was a disaster. After four hours of banging my head against the wall, I needed a new plan. And some help.\nStep Three: The Rewrite (and ChatGPT) #I had a sense of the problem. I know it was caused because I approached the integration wrong. I needed to unify the two sections in bytes. That meant I needed a method to convert my data classes into bytes. That would make it easier to populate them with the parsed DNS data and vice versa.\nModify the Dataclasses with a bytes method #I had been consulting with ChatGPT while researching data storage methods for my cache. When I asked it how to serialize a custom data class object in Python for file storage, it suggested using pickle and storing the data as a byte string.\nThat is fine for file storage, but the problem when I applied the same process in an effort to convert my class objects into byte string was that pickle also includes the information necessary to deserialize the object, which results in a byte string that is completely useless.\nWhen I asked ChatGPT about this issue, it agreed that pickle is not the right choice:\nYou\u0026rsquo;re correct that pickle is not suitable for encoding data where the exact structure and byte count matter, such as in DNS response encoding. Instead, you can implement a custom bytes method that converts the object to a compact binary format, using Python\u0026rsquo;s struct module or manual encoding.\nAhh\u0026hellip;there it was. The solution to the problem. With ChatGPTs help I was able to add custom __bytes__ methods to my dataclasses:\n@dataclass class DNSQuestion: name: str type_: int class_: int def __bytes__(self): name_binary = b\u0026#39;\u0026#39;.join(len(label).to_bytes( 1, \u0026#39;big\u0026#39;) + label.encode(\u0026#39;utf-8\u0026#39;) for label in self.name.split(\u0026#39;.\u0026#39;)) name_binary += b\u0026#39;\\x00\u0026#39; return name_binary + struct.pack(\u0026#34;!HH\u0026#34;, self.type_, self.class_) Now that I had a way to easily convert the dataclasses to bytes, I could proceed with my rewrite.\nStarting Back at the Beginning #I had the answers I needed, but I had no idea where to use them. I knew the best thing to do would be to start over. Not from a blank file, but from something just as effective. I commented out every line of code in my script and I started from the beginning.\nI don\u0026rsquo;t recall all the changes I made. As I worked my way through the code line by line, I uncommented and updated every line necessary to take advantage of the new classes.\nI only uncommented functions as they were called and never the entire function. Just that part of it that did what I needed. I deleted what seemed like dozens of lines of code. I know several functions were removed completely.\nIt took a couple of hours, but starting with a byte string for a google.com DNS request, I verified the response byte string with ChatGPT at every step. I noted where it said the packet was malformed and corrected it. Line by line, I worked through my script.\nWhen I was done, the server would accept a DNS request from a client and return an IP address to the console. All that was left now was to encode a proper response and return it to the client.\nStep Four: Building the Response #There\u0026rsquo;s a better way to do this, but after two solid days of coding, I just wanted to get it working. I attempted to create another dataclass object to contain the response. That would give it a similar structure to the rest of the program, but I couldn\u0026rsquo;t get it to create a properly formed packet. There were errors.\nI took a shortcut and created a proper response using struct and some hard-coded values. This was sufficient to return a proper A record to the client.\ndef build_response(data): dns_header, dns_question = parse_client_request_packet( data) # parse client DNS request # attempt to resolve the client\u0026#39;s request ip_address, ttl = resolve(dns_question.name, dns_question.type_) name = dns_question.name data = bytes(map(int, ip_address.split(\u0026#39;.\u0026#39;))) # Todo: refactor and remove hardcoded values header = struct.pack(\u0026#34;!HHHHHH\u0026#34;, dns_header.id, 0x8180, 1, 1, 0, 0) question = encode_domain_name( name) + struct.pack(\u0026#34;!HH\u0026#34;, dns_question.type_, dns_question.class_) answer = encode_domain_name( name) + struct.pack(\u0026#34;!HHIH\u0026#34;, dns_question.type_, dns_question.class_, ttl, 4) + data return header + question + answer The biggest issue I had was encoding the IP address onto the end of the question string. No matter how I tried, dig kept complaining that my response stiring was malformed and contained extra characters.\nI had to ask ChatGPT for help. it provided this gem that was the key to proper encoding:\ndata = bytes(map(int, ip_address.split(\u0026#39;.\u0026#39;))) Everything up to the #Todo comment is how I want it. The three lines that follow are me building a DNS response using the resolved IP address and some hardcoded integers. I want to rebuild this part of the function to be more dynamic. DNS requests won\u0026rsquo;t always be for a single A record. There is more work to do.\nStep Five: Resolving a DNS Query #Success at last. I started the server and sent it a query from my terminal using:\ndig @localhost -p 5053 google.com The response was exactly what I wanted to see:\n; \u0026lt;\u0026lt;\u0026gt;\u0026gt; DiG 9.10.6 \u0026lt;\u0026lt;\u0026gt;\u0026gt; @localhost -p 5053 google.com ; (2 servers found) ;; global options: +cmd ;; Got answer: ;; -\u0026gt;\u0026gt;HEADER\u0026lt;\u0026lt;- opcode: QUERY, status: NOERROR, id: 46520 ;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0 ;; QUESTION SECTION: ;google.com.\tIN\tA ;; ANSWER SECTION: google.com.\t300\tIN\tA\t142.250.191.238 ;; Query time: 185 msec ;; SERVER: 127.0.0.1#5053(127.0.0.1) ;; WHEN: Mon Nov 18 19:19:12 EST 2024 ;; MSG SIZE rcvd: 54 A perfectly formed DNS response from my Python DNS server.\nThere is so much more work to do on this project. Plus, I want to create a series of posts going over the function in detail once it\u0026rsquo;s complete. The problem is it might be one of those programs that is never complete. Like a chess engine. A perpetual programming project, good for a lifetime of learning or not. Either way,\nThere are only 89 more days to go\u0026hellip;\n","date":"18 November 2024","permalink":"uild/posts/coding/day-11-building-python-dns-server/","section":"Posts","summary":"","title":"Day #11: Building a DNS Server with Python"},{"content":"From my last post, you\u0026rsquo;ll recall I copy-coded two variations on a Python DNS server/resolver. The first project was a server that functions similarly to a nameserver, returning results from a local zone file in response to a request from a client.\nThe second was a custom DNS resolver written in Python that took a domain name input and recursively searched through the Internet DNS hierarchy until it returned an IP address.\nAs the second project is closer to what I had in mind for my own DNS server project, I wanted to start working through the suggested exercises to expand the functionality of my resolver.\nExercise #1: Resolve CNAME Records #Attempting to resolve CNAME records caused the program to crash. This was evident by attempting to resolve www.facebook.com which returned a CNAME record pointing to facebook.com rather than an A record containing an IP address.\nHere\u0026rsquo;s a code snippet from the original code that parsed the response:\nTYPE_A = 1 TYPE_NS = 2 #... def parse_record(reader): #... if type_ == TYPE_NS: data = decode_name(reader) elif type_ == TYPE_A: data = ip_to_string(reader.read(data_len)) else: data = reader.read(data_len) return DNSRecord(name, type_, class_, ttl, data) As you can see, it only supports A and NS records. A CNAME record wouldn\u0026rsquo;t be captured and further decoded. Here\u0026rsquo;s my implementation:\nTYPE = (\u0026#39;\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;NS\u0026#39;, \u0026#39;MD\u0026#39;, \u0026#39;MF\u0026#39;, \u0026#39;CNAME\u0026#39;, \u0026#39;SOA\u0026#39;, \u0026#39;MB\u0026#39;, \u0026#39;MG\u0026#39;, \u0026#39;MR\u0026#39;, \u0026#39;NULL\u0026#39;, \u0026#39;WKS\u0026#39;, \u0026#39;PTR\u0026#39;, \u0026#39;HINFO\u0026#39;, \u0026#39;MINFO\u0026#39;, \u0026#39;MX\u0026#39;, \u0026#39;TXT\u0026#39;) #... def parse_record(reader): #... if type_ == TYPE.index(\u0026#39;NS\u0026#39;): data = decode_name(reader) elif type_ == TYPE.index(\u0026#39;CNAME\u0026#39;): data = decode_name(reader) elif type_ == TYPE.index(\u0026#39;A\u0026#39;): data = ip_to_string(reader.read(data_length)) else: data = reader.read(data_length) You can see two changes. Adding an elif to process the CNAME response allows the resolver to continue towards finding the correct A record instead of erroring out. As NS and CNAME call the same function, I may combine those into a single or condition. This if statement will get longer as I add more record types.\nI also removed the variables for each record type and replaced them with a tuple containing all the possible record types (as of RFC 1035). This makes it simpler, as I don\u0026rsquo;t need to worry about which integer corresponds with which record type. I just need to call my type tuple with the index() method and the name of the record. The integer is returned.\nExercise #1 is complete. My resolver can now handle CNAME resolution. I think this may be the easiest of the exercises to implement.\nExercise #4: Add Caching to the DNS Resolver #While there are many more record types to add, I wanted to move on to caching. This is an important part of a DNS resolver. As the resolver goes about turning domain names into matching IP addresses, it should also keep a record of those matches in local storage.\nThis allows the DNS server to instantly respond to a query from a client without having to perform a full recursive search. This speeds up the response time and greatly reduces the amount of DNS traffic on the network.\nI had a process worked out in my head that went something like this:\nCheck the local cache for a domain name. If found, return the matching IP address. If not, run a recursive search. Write the resulting IP to the cache. Return the IP to the user. It seemed pretty simple, but then I got lost down the rabbit hole of trying to figure out the best data structure to use for a cache. I\u0026rsquo;m leaning toward something like Redis, but for now, I need a cache that works. I can optimize it later. I\u0026rsquo;m going to use a text file.\nStep One: We Need a Cache to Check #Assume the first DNS query won\u0026rsquo;t have a cached entry, let\u0026rsquo;s use that data to start the process. This first function uses pickle to serialize and encode the DNS record and write it to the cache file:\ndef cache_dns_record(dns_record): serialized = base64.b64encode(pickle.dumps(dns_record)).decode(\u0026#39;utf-8\u0026#39;) with open(\u0026#39;cache.txt\u0026#39;, \u0026#39;a\u0026#39;) as file: file.write(serialized + \u0026#34;\\n\u0026#34;) Every time we use a recursive search to find a record, we write that record to the cache, along with a timestamp, which we\u0026rsquo;ll use later to determine TTL.\nI\u0026rsquo;ll need to implement a future method to purge records with expired TTLs from the cache. No point in useless records taking up resources, but this process can wait until I have a better overall caching solution.\nStep Two: Now We Can Check the Cache #Now, when we attempt to resolve a DNS query, we first check the cache for a record:\ndef check_cache(domain_name, record_type): with open(\u0026#39;cache.txt\u0026#39;, \u0026#39;r\u0026#39;) as file: record = {} for line in file: item = pickle.loads(base64.b64decode(line.strip().encode(\u0026#39;utf-8\u0026#39;))) ttl_expired = True if time.time() - item.timestamp \u0026gt; item.ttl else False if item.name == domain_name and record_type == item.type_ and not ttl_expired: record[\u0026#39;ip_address\u0026#39;] = item.data record[\u0026#39;ttl\u0026#39;] = item.ttl return record return In the reverse of the first function, we open the test file, retrieve the cached records and iterate over them, looking for any that match our domain name and record type. If we find one, we use the timestamp in the record to calculate if the time to live (TTL) has expired.\nttl_expired = True if time.time() - item.timestamp \u0026gt; item.ttl else False If the TTL is expired, the cached record is useless, and we proceed to our recursive search to get a fresh record. If the TTL has not expired, we return the cached record, saving us the effort of performing a full search.\nIt\u0026rsquo;s Rudimentary, But it Works! #This is far from an optimal Rudimentary implementation of a cache, but for a coding padawan such as myself, it is sufficient for now. I am exploring other data structures for a more optimized cache. Something like Redis that stores in memory sounds like an interesting idea. We\u0026rsquo;ll come back to that one.\nExercise #7: Create a Full DNS Server #I know I promised you three exercises and so far I\u0026rsquo;ve only shown two. I do have the third one complete, but I can\u0026rsquo;t even begin to describe that process here. It deserves its own post.\nI feel that I\u0026rsquo;m still just getting started with this DNS server project\nIt was a 10-hour grind session that involved combining elements from both previous DNS projects, plenty of discovery into byte encoding, DNS packet construction and an eventual \u0026ldquo;rewrite\u0026rdquo; of the entire program. If you want to read about it, check out tomorrow\u0026rsquo;s blog post.\nAnd I feel that I\u0026rsquo;m still just getting started with this DNS server project. I\u0026rsquo;ve already decided I want to try re-writing it in another language just for fun. Maybe Rust or Haskell? But that\u0026rsquo;s a project for another day.\nLucky for me, I still have 90 more days to go\u0026hellip;\n","date":"17 November 2024","permalink":"uild/posts/coding/day-10-second-day-dns-python-coding/","section":"Posts","summary":"","title":"Day #10: My Second Day of DNS Coding in Python"},{"content":"On Day #2, I posted an article about the differences between tutorial coding and actual coding, albeit from my limited perspective. While tutorials are great, it\u0026rsquo;s not until you strike out on your own and start coding a real application that you begin to cement your learning and strengthen your coding muscles.\nI also mentioned I\u0026rsquo;d need to come up with a project suitable for my first program. I looked at all the standard beginner options: a to-do list, a choose-your-own-adventure game, a password generator, etc. All good options, but none felt inspired.\nLet\u0026rsquo;s build a DNS server!\nThen I had a thought. Let\u0026rsquo;s build a DNS server. As soon as I had the thought, I knew it was crazy. I have several years of experience working with DNS from my day job. Still, a DNS server is not exactly a beginner project. No way I could code that on my own, but I felt it had a sufficient difficulty level that even if I had to rely on tutorials and sample code, the actual implementation of a DNS server would expand my programming knowledge extensively.\nBoy, was I right.\nStep #1: Where Do I Start #I have a solid understanding of DNS from years of experience working with domains and networking. It doesn\u0026rsquo;t begin to prepare me to code my own server. I need some help getting started.\nI found a great YouTube series on building a DNS server with Python. It\u0026rsquo;s over eight years old as of this post, but it\u0026rsquo;s still highly relevant. The first several videos, in particular, where the author explains the RFC 1035 in detail and breaks down the necessary components of a DNS request.\nThe twist is that DNS queries and replies are always sent in bytes:\nb\u0026#39;K\\xdb\\x01 \\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x01\\x06google\\x03com\\x00\\x00\\x01\\x00\\x01\\x00\\x00)\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\u0026#39; This is a byte string representing a DNS request for google.com. The lack of human readability makes parsing the question and encoding the reply more difficult because I can\u0026rsquo;t read the data. Fortunately, this tutorial series was quite good and stepped through encoding each element of the string.\nAs I would learn later, there are more efficient ways of encoding and decoding byte strings in Python (hint: struct), but the manual byte-by-byte encoding of this series helped me form a clear understanding of DNS packet construction.\nI won\u0026rsquo;t spoil the entire tutorial, but I got through the entire copy-coding process (with a few of my own minor adjustments) in about four hours. In the end, I had a functional DNS server that would accept a request from a client (via a dig @localhost command in this case). The program would decode the request, search its local storage for a matching Zone file, encode the DNS response and return the A records to the client.\nA Good Start, But Not What I\u0026rsquo;m After #This was a great first step. I had a functioning server. The issue was I had built a nameserver. A nameserver is a server that holds the zone file for a particular domain. For example, the zone file for this blog\u0026rsquo;s domain stevesansford.com resides on a Cloudflare nameserver.\nWhen that server receives a DNS request for stevesansford.com, the nameserver can access its local records (the zone file) and provide the answer. When your computer first reached out to find the IP address for this blog, my nameserver wasn\u0026rsquo;t the first place it looked. In fact, it was last.\nYour computer got this blog\u0026rsquo;s IP address from the zone file on a Cloudflare nameserver, which it got from the .com tld server, which it got from a root server, which it found via a recursive DNS server.\nWhat I wanted to build was a recursive DNS server (like Google\u0026rsquo;s 8.8.8.8), the first step in the DNS resolution chain. A recursive DNS server doesn\u0026rsquo;t store Zone files. In fact, outside of recently cached information, a recursive server doesn\u0026rsquo;t store anything. It just knows who to ask when it needs an answer to a DNS query from a client.\nI won\u0026rsquo;t expand on the entire process here, but Network Chuck has a superb primer on how DNS functions. If you want a deeper understanding of what I\u0026rsquo;m talking about, please go watch his video.\nStep 2: Building a Recursive DNS Resolver #I went back to the Internet in search of the next step. It was difficult. Lots of information on implementing various open-source DNS solutions, like bind and unbound, but not much on building your own. Then I hit the jackpot!\nI found an e-book (webzine?) from developer Julie Evans on her personal blog, titled Implement DNS in a Weekend. It\u0026rsquo;s a step-by-step walkthrough of creating a DNS resolver that takes a provided domain name and recursively searches (root server \u0026gt; tld server \u0026gt; nameserver) and returns the IP address for the domain.\nThe build is broken into three parts, and the author offers four different ways to utilize the project. I went for step 2 with a twist. I didn\u0026rsquo;t copy and paste the code as suggested but copy-coded it into a Python file. I find this process introduces errors in the code that I then have to find and resolve. It\u0026rsquo;s more engaging than copy-and-paste. Debugging is a useful skill for a programmer.\nI learned a lot about the @dataclass decorator and a couple of clever ways to interact with byte strings.\nAgain, I won\u0026rsquo;t spoil the entire project, but once I worked through all three parts, which took me about 8-hours (with no break), I had a fully functional DNS resolver. I learned a lot about the @dataclass decorator and a couple of clever ways to interact with byte strings. In the end, I could provide the resolver with a domain name, and it would recursively search and return the corresponding IP address.\nFuture Exercises for Future Consideration #The webzine also includes seven additional exercises to further expand the capabilities of the DNS resolver. I want to do them all, but I\u0026rsquo;ll start with the ones which interest me.\nThe three that stood out were adding additional record types, local caching and server functionality.\nThe first suggestion was to add CNAME support. Exercise 2 adds support for other record types. CNAME lookups would crash the resolver. I\u0026rsquo;d like to include AAAA (IPv6) and MX records as well.\nCaching is another exercise I want to implement. Any good resolver will keep a local cache to reduce network load. I\u0026rsquo;m not sure of the best data structure to support it, but even adding rudimentary caching with a text file would be better than nothing.\nThe next one I am going to implement is server functionality. I already copy-coded a functional server, so I plan to integrate the two scripts I have and create a resolver that accepts DNS queries from clients, resolves them with my custom resolver and then returns a properly formatted DNS record to the client.\nSounds easy, right?\nI don\u0026rsquo;t know which other recommended exercises I\u0026rsquo;ll tackle. This project is already big enough for now. Not that I\u0026rsquo;m worried.\nI still have 91 more days to go\u0026hellip;\n","date":"16 November 2024","permalink":"uild/posts/coding/day-9-lets-build-a-dns-server/","section":"Posts","summary":"","title":"Day #9: Let's Build a DNS Server!"},{"content":"There\u0026rsquo;s an important thing to understand about the chess world. The opportunities available to you are highly dependent on your rating. In chess terms, your ELO. An ELO under 800 is a beginner. Over 2200, a master. In between, that\u0026rsquo;s where most serious chess players find themselves.\nMany aspire to be better. They study openings, tactics and theory to expand their knowledge and equip themselves to make better decisions. While making better decisions will improve your ELO over time, too many intermediate players (myself included) wipe away all those gains in a moment with a single bad move.\nIn chess, your rating is determined more by your bad moves than your good ones. I\u0026rsquo;ve played enough chess to know that when I play a good game with no blunders, my projected ELO is in the 1400-1600 range. A solid intermediate player.\nI\u0026rsquo;m past my days of regularly hanging a Queen, but I\u0026rsquo;ll drop a bishop or a knight due to a mistake.\nThen why do I struggle to break 1000 ELO online? The simple answer, I make too many stupid moves. I\u0026rsquo;m past my days of regularly hanging Queens, but I\u0026rsquo;ll drop a bishop or a knight due to a mistake. My only hope at that point is for my opponent (whose ELO is usually close to mine) will make a similar blunder and we\u0026rsquo;ll be even again.\nThat happens often, but not as often as I\u0026rsquo;d like.\nIt Not Just About Chess #What I\u0026rsquo;ve recently realized is this lesson applies to much more than just chess. A questionable decision was made this morning in the Sansford household. It was a relatively minor issue over the nutritional value of a particular breakfast meal. It hit me that you can eat properly all day long, or even for several days, then absolutely blow it on the weekend and set yourself back.\nIt occurred to me that the outcome of our lives is due more to our bad choices than our good ones. You don\u0026rsquo;t often see a single good choice alter the trajectory of someone\u0026rsquo;s life. But every day, there\u0026rsquo;ll be stories in the news of a single bad choice that left someone in ruins. It\u0026rsquo;s tragic how fast one bad decision can ruin a life. It\u0026rsquo;s equally amazing how many consistent good decisions need to be made to effect a positive change.\n\u0026hellip;every day, there\u0026rsquo;ll be stories in the news of a single bad choice that left someone in ruins.\nIn life, like in chess, a few bad decisions can overwrite a lifetime of good ones.\nHow Does This Relate To Coding #I can\u0026rsquo;t help now but turn this theory loose on my programming. I can make good decisions about my project. I can properly plan out every step and execute the plan. Not one of these good decisions on their own is likely to affect the future success of the program.\nAn incorrect decision made anywhere in the process could result in an application that is unusable or unmaintainable in the future.\nBut how about one bad one? Will that completely derail a project? An incorrect decision made anywhere in the build process could result in an application that is unusable or unmaintainable in the future. Remember Y2k? A decision was made to limit the year code to two digits. Look at the chaos that caused. I will admit that the overall outcome of that incident was underwhelming. I\u0026rsquo;d hoped for more.\nThe most interesting issue about this theoretical bad decision is: when does it become a bad decision? I don\u0026rsquo;t think it started that way. I know I\u0026rsquo;m new, but I doubt programmers intentionally make bad decisions in their code. The \u0026lsquo;badness\u0026rsquo; of the decision won\u0026rsquo;t come to light until well after the program\u0026rsquo;s success. Maybe one day I\u0026rsquo;ll find out.\nBut it won\u0026rsquo;t be for at least 92 more days\u0026hellip;\n","date":"15 November 2024","permalink":"uild/posts/coding/day-8-is-everything-defined-by-bad-choices/","section":"Posts","summary":"","title":"Day #8: Is Everything Defined by Bad Decisions?"},{"content":"For no reason whatsoever, I decided that learning Python wasn\u0026rsquo;t difficult enough. So, I committed to writing all of today\u0026rsquo;s lesson code in Neovim. I thought it would be fun to leave the fancy VS Code behind with all the auto-complete, linting, and mouse input and try to produce code in Neovim.\nJust me, my code and a bunch of weird keyboard commands to move the cursor around my document.\nIt will come as no surprise this choice slowed down my progress today, but I don\u0026rsquo;t think it\u0026rsquo;s a bad thing. I love the simplicity of the Vim interface. Maximize the terminal window, and it\u0026rsquo;s like a Zen mode. No IDE. No menus. No mouse. No distractions. Just me, my code and a bunch of weird keyboard commands to move the cursor around my document.\nMaking Simple Things More Complicated #I continued to work through the Bro Code Python course. I\u0026rsquo;m 3 hours and 19 minutes into the 12-hour course. We\u0026rsquo;ve moved into lists, sets, tuples and dictionaries. Still fairly basic, but adding in the extra challenge of coding in Terminal with Neovim ensured the difficulty was sufficient.\n\u0026hellip;but adding in the extra challenge of coding in Terminal with Vim, the difficulty was sufficient.\nThe last exercise I copy-coded was creating a concession stand app to calculate the order total. I didn\u0026rsquo;t pick up anything new in Python, but by the end of the lesson, my Vim skills were slightly more proficient.\nmenu = {\u0026#34;Pizza\u0026#34;: 3.00, \u0026#34;Nachos\u0026#34;: 4.50, \u0026#34;Popcorn\u0026#34;: 6.50, \u0026#34;Fries\u0026#34;: 2.50, \u0026#34;Chips\u0026#34;: 1.50, \u0026#34;Pretzel\u0026#34;: 3.50, \u0026#34;Soda\u0026#34;: 3.00, \u0026#34;Lemonade\u0026#34;: 4.50} cart = [] total = 0 print(\u0026#34;----- MENU ------\u0026#34;) for key, value in menu.items(): print(f\u0026#34;{key:10}: ${value:.2f}\u0026#34;) print(\u0026#34;-----------------\u0026#34;) while True: food = input(\u0026#34;Select an item: (Q to Quit) \u0026#34;) if food.lower() == \u0026#34;q\u0026#34;: break elif menu.get(food) is not None: cart.append(food) print(\u0026#34;------ YOUR ORDER ------\u0026#34;) for item in cart: total += menu.get(item) print(item, end=\u0026#34; \u0026#34;) print() print(f\u0026#34;Your total is: ${total:.2f}\u0026#34;) Neovim also supports Markdown, so I pushed my luck and started typing today\u0026rsquo;s blog post in the terminal as well. That didn\u0026rsquo;t last long. Maybe one day I\u0026rsquo;ll get there, but for now, I\u0026rsquo;m sticking with MacDown for the blogs.\nTackling a 1,000 Digit Number #While I had Neovim open, I thought I would take another shot at Project Euler #8. The challenge is to find out which 13 adjacent digits multiplied together produced the highest number.\nAs I\u0026rsquo;m still well below Project Euler\u0026rsquo;s limit of 100 for sharing solutions outside their platform, I don\u0026rsquo;t mind sharing the script I came up with to find the magic number.\nseries = \u0026#34;7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450\u0026#34; largest_product = 0 for i in range(len(series)): product = 1 adjacent_digits = series[i:i+13] for j in adjacent_digits: product *= int(j) if product \u0026gt; largest_product: largest_product = product print(f\u0026#39;Largest Product: {largest_product}\u0026#39;) I started a loop on the first digit and iterated over the next 12 to find the product. If the product was higher than the previous iteration, I updated my largest_product variable with the new product. At the end of the loop (1000 iterations later), I had the total. Quickly copy and paste into the Project Euler website, and it\u0026rsquo;s time to write a blog post.\nBrilliant is Brilliant #But before I do that, I want to plug the brilliant Brilliant app. I\u0026rsquo;m enjoying it very much. I downloaded it a few days ago and did the first ten lessons in the Computer Science course. Simple programming challenges with block code. I love this style of app, as I\u0026rsquo;ve mentioned before. The game element makes the repetition more enjoyable.\nDeciding I wanted the full version of the app, I went back to one of my favourite chess YouTube channels, ASMRchess. He\u0026rsquo;s advertised Brilliant in several of his recent videos. Using his product code, I was able to get a 30-day free trial (beats the dozen lessons you bet with the base app) and a discount off the annual subscription rate.\nI\u0026rsquo;ll be sure to get plenty of value out of my free trial, but I\u0026rsquo;ve already made the decision to purchase the subscription when the time comes. Thirty days is great\u0026hellip;\nBut we still have 93 more days to go\u0026hellip;\n","date":"14 November 2024","permalink":"uild/posts/coding/day-7-increasing-the-difficulty-level/","section":"Posts","summary":"","title":"Day #7: Increasing the Difficulty Level"},{"content":"My takeaway lesson from today reinforces the idea that programming and coding are two different things. The terms are often used synonymously, but that\u0026rsquo;s incorrect. Coding is the ability to write instructions a computer can follow, and programming is figuring out what instructions the computer needs to produce the desired output.\nI spent part of my morning session finishing the eighth lesson in FreeCodeCamp\u0026rsquo;s Scientific Computing in Python course. It involves creating a \u0026ldquo;shortest path first\u0026rdquo; algorithm. I understand enough about Python to code the instructions I was given, but I struggled to comprehend the flow of instructions in the script.\nI knew what I was writing but not why I was writing it.\nHere\u0026rsquo;s the finished code from the lesson:\nmy_graph = { \u0026#39;A\u0026#39;: [(\u0026#39;B\u0026#39;, 5), (\u0026#39;C\u0026#39;, 3), (\u0026#39;E\u0026#39;, 11)], \u0026#39;B\u0026#39;: [(\u0026#39;A\u0026#39;, 5), (\u0026#39;C\u0026#39;, 1), (\u0026#39;F\u0026#39;, 2)], \u0026#39;C\u0026#39;: [(\u0026#39;A\u0026#39;, 3), (\u0026#39;B\u0026#39;, 1), (\u0026#39;D\u0026#39;, 1), (\u0026#39;E\u0026#39;, 5)], \u0026#39;D\u0026#39;: [(\u0026#39;C\u0026#39;,1 ), (\u0026#39;E\u0026#39;, 9), (\u0026#39;F\u0026#39;, 3)], \u0026#39;E\u0026#39;: [(\u0026#39;A\u0026#39;, 11), (\u0026#39;C\u0026#39;, 5), (\u0026#39;D\u0026#39;, 9)], \u0026#39;F\u0026#39;: [(\u0026#39;B\u0026#39;, 2), (\u0026#39;D\u0026#39;, 3)] } def shortest_path(graph, start, target = \u0026#39;\u0026#39;): unvisited = list(graph) distances = {node: 0 if node == start else float(\u0026#39;inf\u0026#39;) for node in graph} paths = {node: [] for node in graph} paths[start].append(start) while unvisited: current = min(unvisited, key=distances.get) for node, distance in graph[current]: if distance + distances[current] \u0026lt; distances[node]: distances[node] = distance + distances[current] if paths[node] and paths[node][-1] == node: paths[node] = paths[current][:] else: paths[node].extend(paths[current]) paths[node].append(node) unvisited.remove(current) targets_to_print = [target] if target else graph for node in targets_to_print: if node == start: continue print(f\u0026#39;\\n{start}-{node} distance: {distances[node]}\\nPath: {\u0026#34; -\u0026gt; \u0026#34;.join(paths[node])}\u0026#39;) return distances, paths shortest_path(my_graph, \u0026#39;A\u0026#39;, \u0026#39;F\u0026#39;) I was reminded of a Spanish tutor I had some years back. She handed me a page of typed content at our first meeting and asked me to read it. My Spanish at the time was very rudimentary, maybe a 250-word vocabulary, but I could read every word on the page with acceptable pronunciation. I understood none of it.\nThere\u0026rsquo;s a difference between being able to read something (code) and understanding what it means (programming).\nHere\u0026rsquo;s a great 8-minute video on YouTube that explains the Dijkstra Shortest Path algorithm. Watching this first would have helped me understand what the instructions I was writing were trying to do.\nI\u0026rsquo;ll brush up on recursion before I tackle the next lesson in this series.\nNo Such Thing as a Free Lunch #Unless you\u0026rsquo;re looking for coding lessons. Many of the best ones are free. I found one today, even though I wasn\u0026rsquo;t looking for a new one. When watching the recursion video from Bro Code linked above, I got a recommendation for his new 12-hour free Python course posted just two months ago.\nI found his recursion explanation concise and easy to follow, so even though I was short on time, I thought I\u0026rsquo;d put it on and listen to the audio from the car. Turns out that\u0026rsquo;s an interesting way to consume a video tutorial. This Python tutorial is exceptional. I have two key takeaways from the two hours and 38 minutes:\nAudio-Only Might Be a Thing #I\u0026rsquo;ve spent enough time studying chess to appreciate the value of visualization. Visualizing the board in your head and following along with moves is a skill most chess masters have cultivated. It\u0026rsquo;s fascinating to see a grandmaster play a chess game (or three) blindfolded.\nI tried visualizing the code in my head as described in the video. I did not feel I was missing out on anything by not watching the screen.\nListening to the audio from this course on my drive today, I tried visualizing the code in my head as described in the video. I did not feel I was missing out on anything by not watching the screen. It was basic stuff being covered, but this might be something I add to my learning process.\nThis Course is The Best I\u0026rsquo;ve Found #This is entirely subjective, but the BroCode course is exceptional. I\u0026rsquo;ve browsed quite a few beginner Python courses as I prepped for this #100DaysOfCoding challenge, and so far, this video has shown two interesting things in Python that no other course I\u0026rsquo;ve seen explains:\nFormat specifiers: These would have been handy for the FreeCodeCamp Arithmetic Formatter exercise, although the tests would have failed. The built in .help() method: Having a quick reference for methods is useful. Also, the author is soliciting donations to charity in lieu of personal donations. So far, the course has raised over $8,200 for a children\u0026rsquo;s hospital. What more can you ask for?\nI\u0026rsquo;m going to dedicate a portion of my learning time over the next few days (weeks?) to work through this course in its entirety. I like the style, and I want to experiment further with my visualization exercises. Might be nothing.\nWe\u0026rsquo;ll find out in 94 more days\u0026hellip;\n","date":"13 November 2024","permalink":"uild/posts/coding/day-6-programming-and-coding-are-different/","section":"Posts","summary":"","title":"Day #6: Programming and Coding Are Different"},{"content":"I missed my morning session today. Thanks to the late-night session yesterday where I tried to figure out how to build a website with Hugo. I believe it was successful, and even though I have much more to explore (and now I\u0026rsquo;m interested in Go), I\u0026rsquo;m satisfied with its current state.\nI also missed my evening session as I\u0026rsquo;m cramming several days of blog posts into one day so I can get caught up. As I\u0026rsquo;ve mentioned in several previous posts, this idea for the #100DaysOfCoding challenge occurred to me four days into my Python coding journey. I hadn\u0026rsquo;t been taking notes or setting up repositories, or really tracking my progress in any way.\nThere was much work to do to get caught up. Tomorrow, I\u0026rsquo;ll get back into my proper coding schedule. I want to finish the next module in my FreeCodeCamp.org course. I\u0026rsquo;m working on basic algorithms by creating a shortest-path script.\nI also want to spend some time on a couple of short (or one longer) copy-coding tutorials on YouTube. They\u0026rsquo;re not the best way to learn to code, but I do get enough value from them for the time invested.\nI did manage to listen to a couple of interesting videos today. The first was a 90-second video on how to keep coding enjoyable. The premise was to set small goals and consistently reach them. An interesting approach.\nEven a small program can be hundreds of lines of code. Breaking that up into a series of small wins would be advantageous. Instead of grinding for hours and maybe celebrating a completed program, set a goal to write a single function for that script in the next 30 minutes. Celebrate when it\u0026rsquo;s done. Move on to the next brick in the wall.\nThe second video was from Fireship on a development roadmap, where he used an iceberg analogy to show the history of programming languages. It was interesting to hear about the development of the most popular languages and some of the more eccentric ones.\nI wonder if I can knock out a few Project Euler challenges with Emojicode?\nMaybe we\u0026rsquo;ll find out in 95 days\u0026hellip;\n","date":"12 November 2024","permalink":"uild/posts/coding/day-5-im-finally-caught-up/","section":"Posts","summary":"","title":"Day #5: I'm Finally Caught Up...I Think"},{"content":"Portfolio #","date":"12 November 2024","permalink":"uild/portfolio/","section":"Steve Sansford","summary":"","title":"Portfolio"},{"content":"About Me #","date":"12 November 2024","permalink":"uild/about/","section":"Steve Sansford","summary":"","title":"About"},{"content":"One of the biggest issues I need to deal with is the distractions that come from discovering something new. Prior to begining this series, I was poking around the Internet looking at various lanuages and frameworks in a effort to determine a starting point.\nI spent a couple of weeks refreshing my basic HTML, CSS and JavaScript skills. I worked through a couple of great tutorials. Then I explored React which let to the discovery of SvelteKit. I very much liked what I found, but it isn\u0026rsquo;t what I am seeking.\nBeware the Mighty Rabbit Hole #My problem is that if I start my jorney with a frontend stack, I\u0026rsquo;d quickly fall down a rabbit hole. I will obsess over pixel-perfect perfection, even though my design skills are non-existent. I\u0026rsquo;ll get stuck changing colors and moving things one pixel to the right, just to end up moving it back. It\u0026rsquo;s very unproductive and no condusive to learning to code.\nEven though JavaScript is a fantasitc place to start, the nature of it genrally involves HTML and CSS (Don\u0026rsquo;t hate me Node.js people). I\u0026rsquo;m well-aware that anything that can be written in JavaScript will be written in JavaScript. Including plenty of non-frontend project.\nThen I thought let\u0026rsquo;s give Python a try. There are a lot more tutorials and challenges out there for Python that don\u0026rsquo;t involve fronend development. Turns out, this is what I was looking for. I\u0026rsquo;ve been coding with python for almost a week now, and I haven\u0026rsquo;t touched a character of HTML or CSS\u0026hellip;until today.\nMeet My New Friend HUGO #The idea for this project came four days into my Python experiment. While the simple thing to do whould be just to write down my daily projects in a text editor and figure out how to publish them on day 101, my curiosity got the best of me.\nI knew I wanted to use a markdown-based system for my coding notes. So I started looking for a framework I could use to convert my markdown files into the HTML documents you are reading now. All while minimizing the amount of frontend coding I would need to do.\nWordPress would have been the easiest, but I\u0026rsquo;ve been there more times than I can count. I am also fascinated by the idea of a statically -generated site for speed and performance. It is possible with SvelteKit, as I had already discovered.\nMy 8-Hour Hugo Crash Course #But it turns out that for what I had in mind, Hugo looks like the ideal choice. My Python projects totally abandoned, I was up until the wee hours of the morning learning the basics of how Hugo operates. How to install it. How the configurations work. How to make it work with Tailwind CSS (the biggest challenge) and how to use it to render Markdown files as HTML.\nIt was an 8-hour crash course, but the result is the website upon which you are now reading these words. Hugo is an intersting platform, although I don\u0026rsquo;t understand Go enough to know what it\u0026rsquo;s actually doing. Getting it setup with a basic theme is super-easy. It\u0026rsquo;s very fast and renders Markdown well.\nPushing it to a platform like GitHub Pages is also straight-forward, or so I\u0026rsquo;m told. I plan to run it locally until Day 100 is completed so I can push the entire project at once. That might not be ideal for several reasons, but realeasing this inforamtion to the world is my reward for reaching 100 Days.\nI\u0026rsquo;m hoping it\u0026rsquo;s worth the wait\u0026hellip;\n","date":"11 November 2024","permalink":"uild/posts/coding/day-4-i-got-sidetracked-by-hugo/","section":"Posts","summary":"","title":"Day #4: I Got Distracted by Hugo!"},{"content":"In yesterday\u0026rsquo;s post, I attempted to illustrate the differences between \u0026lsquo;copy-coding\u0026rsquo; tutorials and actually writing code. Even after just a few days of my project, I\u0026rsquo;ve already noticed the code I remember is the code I wrote without following a tutorial.\nThe problem is I\u0026rsquo;m never sure what to write. I don\u0026rsquo;t have a project in mind for my Python code, so I\u0026rsquo;ve been looking for ideas. This is where I discovered the concept of coding challenges. I started with a course from Code with Mosh that contains a dozen or so Python projects in two-part videos. The first one lays out the challenge. The second shows his solution. I found these interesting.\nThe trick was to watch the first video and then complete the project on my own, including the extra features listed in the accompanying PDF. Once my program was functional, I would watch the second video and see where I could improve.\nCompleting Coding Challenges #The first project was a dice-rolling game. The premise was to write a script that would prompt the user to roll two dice and then return the values. Fairly straightforward. The extra credit challenge was to allow the user to select the number of dice to roll and count the total number of rolls. Here\u0026rsquo;s what I came up with:\nimport random print(\u0026#39;\\nWelcome to the Dice Rolling Game!\\n\u0026#39;) counter = 1 while True: user_choice = input(\u0026#34;Roll the dice? (y/n): \u0026#34;) if user_choice.lower() == \u0026#39;y\u0026#39;: number_of_dice = input(\u0026#39;How many dice would you like to roll? \u0026#39;) list_of_results = [] for i in range(int(number_of_dice)): list_of_results.append(random.randint(1, 6)) print(f\u0026#39;\\nRoll {counter}: {list_of_results}\\n\u0026#39;) counter += 1 elif user_choice.lower() == \u0026#39;n\u0026#39;: print(\u0026#39;\\nExiting game...\\n\u0026#39;) break else: print(\u0026#39;\\nYou should make better choices!\\n\u0026#39;) I made it through the first two lessons and am working on the third, a rock-paper-scissors game. You can view the code for these projects in my GitHub repository.\nWhat About Free Coding Challenges? #The disadvantage is this challenge course is not free. Mosh sells his courses, and while they do provide good value, there are similar resources available for free that would serve the same purpose. Although, the solutions may not be as detailed.\nOne suggestion I have not yet tried is to use ChatGPT (or another similar platform) to provide a series of beginner challenges and a series of tests to prove the solution. I\u0026rsquo;m doubtful this will work for more complicated programs, I have enough experience with ChatGPT to believe that it can produce challenges suitable for my current skill level. I\u0026rsquo;ve added this to my list of coding things to try, so check back in a few days.\nOne thing of interest I did find was Project Euler. It\u0026rsquo;s a series of 904 (at last count) challenges, starting with basic and progressing to considerable difficulty. The problems are math-based, and although I have successfully completed the first eight challenges, I found that the limiting factor was my understanding of mathematical concepts and not my coding.\nThe Project Euler website is dated but serves its purpose. The advantage is there\u0026rsquo;s no language requirement. You can use any language you want to determine the answer to the problem. FreeCodeCamp.org has the first 480 lessons available on their platform in JavaScript. If that\u0026rsquo;s your language, you may find the interface on FreeCodeCamp.com more useful. As I\u0026rsquo;m using Python, I wrote my code in VSCode and then manually entered my answer on the Project Euler website. I\u0026rsquo;m enjoying this challenge very much, and it\u0026rsquo;s helping me to expand both my coding ability and mathematical skills.\nCoding Challenges Produce Results #So far, I\u0026rsquo;ve found this type of challenge the most productive. Not only do I need to learn the Python syntax necessary to provide the solution, but I also need to apply logic and problem-solving skills (and let\u0026rsquo;s not forget the math) to figure out what I need to do before I even attempt to write the code. Project Euler suggests starting with a pencil and paper until you have an understanding of the problem and an outline to solve the problem. That\u0026rsquo;s a great suggestion for any programming project.\nWe\u0026rsquo;ve only got 97 days to go\u0026hellip;\n","date":"10 November 2024","permalink":"uild/posts/coding/day-3-the-value-of-coding-challenges/","section":"Posts","summary":"","title":"Day #3: The Value of Coding Challenges"},{"content":"The sheer amount of coding material on the Internet is overwhelming. It\u0026rsquo;s easy to get lost in what the community calls \u0026lsquo;Tutorial Hell.\u0026rsquo; Students get stuck in an endless process of watching tutorials on YouTube for hours on end, with no appreciable gain in skill.\nI\u0026rsquo;m not saying that it\u0026rsquo;s impossible to learn coding from watching videos, but it\u0026rsquo;s sort of like learning to ride a bike by reading a book about riding a bike. It can tell you all the theories and best practices, but until you get out on your bike and fall off a few times, you\u0026rsquo;ll never learn how to do it.\nCoding is the same. This isn\u0026rsquo;t to say coding tutorials have no value. So far in my short journey, I\u0026rsquo;ve found them to provide tremendous value when used in a specific way.\n\u0026lsquo;Copy-Coding\u0026rsquo; as a Discovery Tool #\u0026lsquo;Copy-coding\u0026rsquo; as I call it, is the process of following along with a tutorial and copying the code they write line by line until you end up with a completed project.\nI get two benefits from this process. First, I learn what to expect from the language. I don\u0026rsquo;t focus on the syntax and structure of the code. Rather, I try to focus on the idea behind the code. What is the programmer trying to accomplish? How does the language enable the solution?\nSecond, even though my focus isn\u0026rsquo;t on the syntax or structure, I can\u0026rsquo;t help but absorb the patterns. Certain structures start feeling natural even after only a few hours of coding. These are basic structures but essential to a fundamental understanding of the code.\nThe Real Trick to Learning a Skill #Learned knowledge is powerful, but it cannot compare to practical knowledge. Just like the best way to learn to ride a bike is to jump on one and give it a shot, the best way to learn coding is to jump in, sans tutorial, and just figure stuff out.\nIt\u0026rsquo;s not easy to sit down in front of a blank editor and just bang out some code, so I\u0026rsquo;ve found some structures I can use to help jumpstart the process.\nMy favourite so far is the courses on FreeCodeCamp.org. I know, that\u0026rsquo;s painfully obvious. The lessons are well-built and start with a series of instructions that build out a functional application from the ground up. There are elements of \u0026lsquo;copy-coding\u0026rsquo; in some of the steps, but more than a few required me to go look up a solution in the Python docs. That\u0026rsquo;s how to learn.\nHere\u0026rsquo;s an example of one of the lessons where I followed the instructions (and looked up a few things) to create a random password generator:\nimport secrets import string def generate_password(length=16384, nums=1, special_chars=1, uppercase=1, lowercase=1): # Define the possible characters for the password letters = string.ascii_letters digits = string.digits symbols = string.punctuation # Combine all characters all_characters = letters + digits + symbols while True: password = \u0026#39;\u0026#39; # Generate password for _ in range(length): password += secrets.choice(all_characters) constraints = [ (nums, r\u0026#39;\\d\u0026#39;), (special_chars, fr\u0026#39;[{symbols}]\u0026#39;), (uppercase, r\u0026#39;[A-Z]\u0026#39;), (lowercase, r\u0026#39;[a-z]\u0026#39;) ] # Check constraints if all( constraint \u0026lt;= len(re.findall(pattern, password)) for constraint, pattern in constraints ): break return password if __name__ == \u0026#39;__main__\u0026#39;: new_password = generate_password() print(\u0026#39;Generated password:\u0026#39;, new_password) It was fun to see this script crank out a 16,384-character random password. Too bad I can\u0026rsquo;t use it on my Netflix account!\nMy First Solo Flight #To drive the lesson even further, each module comes with a final project. You\u0026rsquo;re given criteria for a program, and you need to produce a solution entirely on your own that passes a series of pre-determined tests. So far, in my short 2-day journey, this was the most interesting thing I\u0026rsquo;ve found.\nThe first project was to create a Python script that would take a list of arithmetic functions and pretty-print them to the console. There was an added twist that if the function call was flagged \u0026lsquo;True\u0026rsquo; the output also had to include the result of the calculation.\nHere\u0026rsquo;s a link to my solution on my GitHub. It\u0026rsquo;s messy, but it works. It passed all the tests. I plan to revisit this challenge in a few months to see what the new solution looks like.\nUntil then, only 98 more days to go\u0026hellip;\n","date":"9 November 2024","permalink":"uild/posts/coding/day-2-coding-tutorials-vs-actually-coding/","section":"Posts","summary":"","title":"Day #2: Coding Tutorials vs. Actually Coding"},{"content":"My goal is to become an expert programmer. I know it\u0026rsquo;ll take much more than 100 days, but you know what they say about a journey of 1000 miles. It starts with a single step.\nAs for my first step, I should decide on a language. I\u0026rsquo;m somewhat flexible on the choice. JavaSript and Python are the two clear contenders. They both have massive communities, so support is readily available. So are training resources. Every conceivable method of learning is available for both languages.\nI have a few projects in mind I\u0026rsquo;d like to develop. I feel JavaScript would be the best suited for those projects. Most are frontend apps, but past experience (mostly with WordPress blogs/themes) has taught me that I will spend too much time on pixel-perfecting and not enough on actually learning to code.\nShould I Start with JavaScript or Python? #I think I\u0026rsquo;ll start with Python. I know JS isn\u0026rsquo;t all front-end work, but most of the training resources I\u0026rsquo;ve found include HTML and CSS. That\u0026rsquo;s not what I\u0026rsquo;m looking for. Python feels like the better choice. It\u0026rsquo;s equally popular and ubiquitous, but the beginner training trends more towards a CLI-based approach, which will keep me away from the deeper rabbit hole I know I\u0026rsquo;ll fall into.\nI\u0026rsquo;ve dabbled in Python a little over my years in IT. I doubt I\u0026rsquo;ve written more than a few dozen lines of code. I looked at it for my chess engine project but dismissed it in favour of a lower-level language. As you\u0026rsquo;ll recall from yesterday\u0026rsquo;s post, my focus was on the engine and not on learning the language.\nNow, I want to learn to be an expert program and become completely fluent in my chosen language. I\u0026rsquo;ll start with Python and see where it goes. As an aside, given its popularity for machine learning and data science, it\u0026rsquo;s likely a road whose end I may never see. But that\u0026rsquo;s half the fun.\nHow I Plan to Structure My Learning #I plan to spend three hours each day learning my new craft. I\u0026rsquo;ve broken it up into two 90-minute sessions. One focused on coding along with training tutorials. The second focused on writing code on my own, likely in the form of challenges until I have an idea of some basic apps I\u0026rsquo;d like to write.\nFor instance, I\u0026rsquo;d like a script that runs every night on my computer and sweeps all the screenshots off my desktop into a folder or maybe the trash. I use screenshots (or snippets) a lot for my day job, and every few days I need to tidy up my desktop. Perhaps a script to automate the process would be an interesting project.\nIf I find myself with extra time throughout my day, I\u0026rsquo;ll spend a few minutes on a learning app like Brilliant. I love the gamified format. It works well for me with Duolingo and my Spanish lessons. I\u0026rsquo;ve also dabbled in German, Russian and French. I\u0026rsquo;ve just started with Brilliant. I haven\u0026rsquo;t decided if I want to spring for the full version. Any feedback from current users would be appreciated. I also tried Mimo, but I feel it\u0026rsquo;s just a limited version of Brilliant.\nLike any good plan, this one is likely to fall apart quickly. But then I\u0026rsquo;ll just re-adjust and keep moving forward.\nOnly 99 more days to go\u0026hellip;\n","date":"8 November 2024","permalink":"uild/posts/coding/day-1-laying-the-groundwork/","section":"Posts","summary":"","title":"Day #1: Laying the Groundwork"},{"content":"Credit where credit is due. This idea came right from a Tech with Tim video on how to make money from coding. The suggestion was to do a 100-day challenge as the start of a personal brand. So here it is. I\u0026rsquo;m going to spend the next 100 days learning how to code. The results, both good and bad, will be posted here on my blog for everyone to see.\nA Brief History Lesson #First, we should establish a bit of history. I\u0026rsquo;m not new to programming, but I\u0026rsquo;m very rusty and inexperienced in modern coding languages and techniques. More than 20 years ago, I was employed for a period of time as a web developer, building sites with PHP and MySQL. I also built several Windows apps in Visual Basic. Life took me away from coding for many years.\nI re-discovered coding about a year ago after re-discovering chess. I\u0026rsquo;m fascinated by chess, but I was dealing with anxiety when playing real games. (Thanks GothamChess for normalizing that for us all) I turned to the idea of computer chess as a way to enjoy the game and not have to deal with the anxiety of playing against actual people. I played well against bots.\nI started poking around and rediscovering coding through various chess engine tutorials. I copy-coded a chess engine in C. I made several attempts to write an engine in Rust. I may revisit this one. After a few weeks, I found myself not interested in coding but only learning it as a means to an end.I wans\u0026rsquo;t interested in the coding. Coding is impossible to learn if it\u0026rsquo;s not something you\u0026rsquo;re passionate about.\nFortunately, I am passionate about learning, and even though my re-introduction to coding was put on the shelf, it\u0026rsquo;s been recently dusted off and I\u0026rsquo;m genuinely interested to see where it goes.\nHere We Go Again #The second (or third) bout with coding was ignited by a Dan Martell video. (Seriously, if you don\u0026rsquo;t know who this guy is, look him up). He has a popular YouTube channel and his content focuses on entrepreneurship, particularly around software development. In several videos (this one in particular) he lays out the steps he\u0026rsquo;d take if starting over. Step One is to learn a high-value skill. He lists five: coding, content creation, copywriting, project management and sales.\nAll of those I have done. Meaning I\u0026rsquo;ve been paid professionally for providing those services, but I\u0026rsquo;ve never been able to manifest one of them into a sustainable business. I\u0026rsquo;m not blaming them, but they never worked for me. Despite that, I knew that coding was not an option. Too hard. Too much to learn. Too many people doing it. Wasn\u0026rsquo;t for me.\nExcept it\u0026rsquo;s all I could think about for days after watching that video. I realized that my mistake was writing off that skill for no reason. I love to learn new things. Coding is endless. I enjoy building useful things. Coding is useful. My lifestyle prevents me from building physical things (more on that later), but I could satisfy my desire to construct by doing it digitally. Coding is a valuable life skill that I can teach to my children.\nCoding is Really Hard #Yes, coding is hard to learn. Programming is even harder (yes, they are different). But when faced with a choice between two paths, take the harder one. As the kids used to say, the juice is worth the squeeze.\nMy goal is to spend three hours every day learning to code. At the end of the day (hopefully) I\u0026rsquo;ll summarize the day\u0026rsquo;s progress in a blog post that I will post to my website. I\u0026rsquo;ll include code examples as written and after 100 days, we can revisit some of them and see how far I\u0026rsquo;ve progressed. I haven\u0026rsquo;t decided which other platforms I\u0026rsquo;ll share this journey on. As you\u0026rsquo;ll recall, content creation is not an enjoyable process for me. But then again, neither is copywriting, yet here we are.\nIn hindsight, I\u0026rsquo;m beginning to understand the key to that Dan Martell video is to not only pick a skill and become great at it but also develop the other four. If you want a job as a programmer, being a great coder is enough. If you want to build something amazing, you need to tell people about it (content creation), describe it in detail (copywriting), keep everything on track (project management), and market it to the world (selling).\nThis is going to be interesting\u0026hellip;\n","date":"7 November 2024","permalink":"uild/posts/coding/day-0-a-brief-history-lesson/","section":"Posts","summary":"","title":"Day #0: A Brief History Lesson"},{"content":"","date":null,"permalink":"uild/categories/","section":"Categories","summary":"","title":"Categories"}]