[{"content":"","date":null,"permalink":"/tags/%23100daysofcoding/","section":"Tags","summary":"","title":"#100DaysOfCoding"},{"content":"My takeaway lesson from today reinforces the idea that programming and coding are two different things. The terms are often used synonymously, but that\u0026rsquo;s incorrect. Coding is the ability to write instructions a computer can follow, and programming is figuring out what instructions the computer needs to produce the desired output.\nI spent part of my morning session finishing the eighth lesson in FreeCodeCamp\u0026rsquo;s Scientific Computing in Python course. It involves creating a \u0026ldquo;shortest path first\u0026rdquo; algorithm. I understand enough about Python to code the instructions I was given, but I struggled to comprehend the flow of instructions in the script.\nI knew what I was writing but not why I was writing it.\nHere\u0026rsquo;s the finished code from the lesson:\nmy_graph = { \u0026#39;A\u0026#39;: [(\u0026#39;B\u0026#39;, 5), (\u0026#39;C\u0026#39;, 3), (\u0026#39;E\u0026#39;, 11)], \u0026#39;B\u0026#39;: [(\u0026#39;A\u0026#39;, 5), (\u0026#39;C\u0026#39;, 1), (\u0026#39;F\u0026#39;, 2)], \u0026#39;C\u0026#39;: [(\u0026#39;A\u0026#39;, 3), (\u0026#39;B\u0026#39;, 1), (\u0026#39;D\u0026#39;, 1), (\u0026#39;E\u0026#39;, 5)], \u0026#39;D\u0026#39;: [(\u0026#39;C\u0026#39;,1 ), (\u0026#39;E\u0026#39;, 9), (\u0026#39;F\u0026#39;, 3)], \u0026#39;E\u0026#39;: [(\u0026#39;A\u0026#39;, 11), (\u0026#39;C\u0026#39;, 5), (\u0026#39;D\u0026#39;, 9)], \u0026#39;F\u0026#39;: [(\u0026#39;B\u0026#39;, 2), (\u0026#39;D\u0026#39;, 3)] } def shortest_path(graph, start, target = \u0026#39;\u0026#39;): unvisited = list(graph) distances = {node: 0 if node == start else float(\u0026#39;inf\u0026#39;) for node in graph} paths = {node: [] for node in graph} paths[start].append(start) while unvisited: current = min(unvisited, key=distances.get) for node, distance in graph[current]: if distance + distances[current] \u0026lt; distances[node]: distances[node] = distance + distances[current] if paths[node] and paths[node][-1] == node: paths[node] = paths[current][:] else: paths[node].extend(paths[current]) paths[node].append(node) unvisited.remove(current) targets_to_print = [target] if target else graph for node in targets_to_print: if node == start: continue print(f\u0026#39;\\n{start}-{node} distance: {distances[node]}\\nPath: {\u0026#34; -\u0026gt; \u0026#34;.join(paths[node])}\u0026#39;) return distances, paths shortest_path(my_graph, \u0026#39;A\u0026#39;, \u0026#39;F\u0026#39;) I was reminded of a Spanish tutor I had some years back. She handed me a page of typed content at our first meeting and asked me to read it. My Spanish at the time was very rudimentary, maybe a 250-word vocabulary, but I could read every word on the page with acceptable pronunciation. I understood none of it.\nThere\u0026rsquo;s a difference between being able to read something (code) and understanding what it means (programming).\nHere\u0026rsquo;s a great 8-minute video on YouTube that explains the Dijkstra Shortest Path algorithm. Watching this first would have helped me understand what the instructions I was writing were trying to do.\nI\u0026rsquo;ll brush up on recursion before I tackle the next lesson in this series.\nNo Such Thing as a Free Lunch #Unless you\u0026rsquo;re looking for coding lessons. Many of the best ones are free. I found one today, even though I wasn\u0026rsquo;t looking for a new one. When watching the recursion video from Bro Code linked above, I got a recommendation for his new 12-hour free Python course posted just two months ago.\nI found his recursion explanation concise and easy to follow, so even though I was short on time, I thought I\u0026rsquo;d put it on and listen to the audio from the car. Turns out that\u0026rsquo;s an interesting way to consume a video tutorial. This Python tutorial is exceptional. I have two key takeaways from the two hours and 38 minutes:\nAudio-Only Might Be a Thing #I\u0026rsquo;ve spent enough time studying chess to appreciate the value of visualization. Visualizing the board in your head and following along with moves without is a skill most chess masters have cultivated. It\u0026rsquo;s fascinating to see a grandmaster play a chess game (or three) blindfolded.\nI found myself visualizing the code in my head as it was described in the video. I did not feel I was missing out on anything by not watching the screen.\nAs I was listening to the audio from this course on my drive today, I found myself visualizing the code in my head as it was described in the video. I did not feel I was missing out on anything by not watching the screen. It was basic stuff being covered, but this might be something I add to my learning process.\nThis Course is The Best I\u0026rsquo;ve Found #This is entirely subjective, but the BroCode course is exceptional. I\u0026rsquo;ve browsed quite a few beginner Python courses as I prepped for this #100DaysOfCoding challenge, and so far, this video has shown two interesting things in Python that no other course I\u0026rsquo;ve seen explains:\nFormat specifiers: These would have been handy for the FreeCodeCamp Arithmetic Formatter exercise, although the tests would have failed. The built in .help() method: Having a quick reference for methods is useful. Also, the author is soliciting donations to charity in lieu of personal donations. So far, the course has raised over $8,200 for a children\u0026rsquo;s hospital. What more can you ask for?\nI\u0026rsquo;m going to dedicate a portion of my learning time over the next few days (weeks?) to work through this course in its entirety. I like the style, and I want to experiment further with my visualization exercises. Might be nothing.\nWe\u0026rsquo;ll find out in 94 more days\u0026hellip;\n","date":"13 November 2024","permalink":"/posts/day-6-programming-and-coding-are-different/","section":"Posts","summary":"","title":"Day #6: Programming and Coding Are Different"},{"content":"","date":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":null,"permalink":"/","section":"Steve Sansford","summary":"","title":"Steve Sansford"},{"content":"","date":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"I missed my morning session today. Thanks to the late-night session yesterday where I tried to figure out how to build a website with Hugo. I believe it was successful, and even though I have much more to explore (and now I\u0026rsquo;m interested in Go), I\u0026rsquo;m satisfied with its current state.\nI also missed my evening session as I\u0026rsquo;m cramming several days of blog posts into one day so I can get caught up. As I\u0026rsquo;ve mentioned in several previous posts, this idea for the #100DaysOfCoding challenge occurred to me four days into my Python coding journey. I hadn\u0026rsquo;t been taking notes or setting up repositories, or really tracking my progress in any way.\nThere was much work to do to get caught up. Tomorrow, I\u0026rsquo;ll get back into my proper coding schedule. I want to finish the next module in my FreeCodeCamp.org course. I\u0026rsquo;m working on basic algorithms by creating a shortest-path script.\nI also want to spend some time on a couple of short (or one longer) copy-coding tutorials on YouTube. They\u0026rsquo;re not the best way to learn to code, but I do get enough value from them for the time invested.\nI did manage to listen to a couple of interesting videos today. The first was a 90-second video on how to keep coding enjoyable. The premise was to set small goals and consistently reach them. An interesting approach.\nEven a small program can be hundreds of lines of code. Breaking that up into a series of small wins would be advantageous. Instead of grinding for hours and maybe celebrating a completed program, set a goal to write a single function for that script in the next 30 minutes. Celebrate when it\u0026rsquo;s done. Move on to the next brick in the wall.\nThe second video was from Fireship on a development roadmap, where he used an iceberg analogy to show the history of programming languages. It was interesting to hear about the development of the most popular languages and some of the more eccentric ones.\nI wonder if I can knock out a few Project Euler challenges with Emojicode?\nMaybe we\u0026rsquo;ll find out in 95 days\u0026hellip;\n","date":"12 November 2024","permalink":"/posts/day-5-im-finally-caught-up/","section":"Posts","summary":"","title":"Day #5: I'm Finally Caught Up...I Think"},{"content":"Portfolio #","date":"12 November 2024","permalink":"/portfolio/","section":"Steve Sansford","summary":"","title":"Portfolio"},{"content":"About Me #","date":"12 November 2024","permalink":"/about/","section":"Steve Sansford","summary":"","title":"About"},{"content":"One of the biggest issues I need to deal with is the distractions that come from discovering something new. Prior to begining this series, I was poking around the Internet looking at various lanuages and frameworks in a effort to determine a starting point.\nI spent a couple of weeks refreshing my basic HTML, CSS and JavaScript skills. I worked through a couple of great tutorials. Then I explored React which let to the discovery of SvelteKit. I very much liked what I found, but it isn\u0026rsquo;t what I am seeking.\nBeware the Mighty Rabbit Hole #My problem is that if I start my jorney with a frontend stack, I\u0026rsquo;d quickly fall down a rabbit hole. I will obsess over pixel-perfect perfection, even though my design skills are non-existent. I\u0026rsquo;ll get stuck changing colors and moving things one pixel to the right, just to end up moving it back. It\u0026rsquo;s very unproductive and no condusive to learning to code.\nEven though JavaScript is a fantasitc place to start, the nature of it genrally involves HTML and CSS (Don\u0026rsquo;t hate me Node.js people). I\u0026rsquo;m well-aware that anything that can be written in JavaScript will be written in JavaScript. Including plenty of non-frontend project.\nThen I thought let\u0026rsquo;s give Python a try. There are a lot more tutorials and challenges out there for Python that don\u0026rsquo;t involve fronend development. Turns out, this is what I was looking for. I\u0026rsquo;ve been coding with python for almost a week now, and I haven\u0026rsquo;t touched a character of HTML or CSS\u0026hellip;until today.\nMeet My New Friend HUGO #The idea for this project came four days into my Python experiment. While the simple thing to do whould be just to write down my daily projects in a text editor and figure out how to publish them on day 101, my curiosity got the best of me.\nI knew I wanted to use a markdown-based system for my coding notes. So I started looking for a framework I could use to convert my markdown files into the HTML documents you are reading now. All while minimizing the amount of frontend coding I would need to do.\nWordPress would have been the easiest, but I\u0026rsquo;ve been there more times than I can count. I am also fascinated by the idea of a statically -generated site for speed and performance. It is possible with SvelteKit, as I had already discovered.\nMy 8-Hour Hugo Crash Course #But it turns out that for what I had in mind, Hugo looks like the ideal choice. My Python projects totally abandoned, I was up until the wee hours of the morning learning the basics of how Hugo operates. How to install it. How the configurations work. How to make it work with Tailwind CSS (the biggest challenge) and how to use it to render Markdown files as HTML.\nIt was an 8-hour crash course, but the result is the website upon which you are now reading these words. Hugo is an intersting platform, although I don\u0026rsquo;t understand Go enough to know what it\u0026rsquo;s actually doing. Getting it setup with a basic theme is super-easy. It\u0026rsquo;s very fast and renders Markdown well.\nPushing it to a platform like GitHub Pages is also straight-forward, or so I\u0026rsquo;m told. I plan to run it locally until Day 100 is completed so I can push the entire project at once. That might not be ideal for several reasons, but realeasing this inforamtion to the world is my reward for reaching 100 Days.\nI\u0026rsquo;m hoping it\u0026rsquo;s worth the wait\u0026hellip;\n","date":"11 November 2024","permalink":"/posts/day-4-i-got-sidetracked-by-hugo/","section":"Posts","summary":"","title":"Day #4: I Got Distracted by Hugo!"},{"content":"In yesterday\u0026rsquo;s post, I attempted to illustrate the differences between \u0026lsquo;copy-coding\u0026rsquo; tutorials and actually writing code. Even after just a few days of my project, I\u0026rsquo;ve already noticed the code I remember is the code I wrote without following a tutorial.\nThe problem is I\u0026rsquo;m never sure what to write. I don\u0026rsquo;t have a project in mind for my Python code, so I\u0026rsquo;ve been looking for ideas. This is where I discovered the concept of coding challenges. I started with a course from Code with Mosh that contains a dozen or so Python projects in two-part videos. The first one lays out the challenge. The second shows his solution. I found these interesting.\nThe trick was to watch the first video and then complete the project on my own, including the extra features listed in the accompanying PDF. Once my program was functional, I would watch the second video and see where I could improve.\nCompleting Coding Challenges #The first project was a dice-rolling game. The premise was to write a script that would prompt the user to roll two dice and then return the values. Fairly straightforward. The extra credit challenge was to allow the user to select the number of dice to roll and count the total number of rolls. Here\u0026rsquo;s what I came up with:\nimport random print(\u0026#39;\\nWelcome to the Dice Rolling Game!\\n\u0026#39;) counter = 1 while True: user_choice = input(\u0026#34;Roll the dice? (y/n): \u0026#34;) if user_choice.lower() == \u0026#39;y\u0026#39;: number_of_dice = input(\u0026#39;How many dice would you like to roll? \u0026#39;) list_of_results = [] for i in range(int(number_of_dice)): list_of_results.append(random.randint(1, 6)) print(f\u0026#39;\\nRoll {counter}: {list_of_results}\\n\u0026#39;) counter += 1 elif user_choice.lower() == \u0026#39;n\u0026#39;: print(\u0026#39;\\nExiting game...\\n\u0026#39;) break else: print(\u0026#39;\\nYou should make better choices!\\n\u0026#39;) I made it through the first two lessons and am working on the third, a rock-paper-scissors game. You can view the code for these projects in my GitHub repository.\nWhat About Free Coding Challenges? #The disadvantage is this challenge course is not free. Mosh sells his courses, and while they do provide good value, there are similar resources available for free that would serve the same purpose. Although, the solutions may not be as detailed.\nOne suggestion I have not yet tried is to use ChatGPT (or another similar platform) to provide a series of beginner challenges and a series of tests to prove the solution. I\u0026rsquo;m doubtful this will work for more complicated programs, I have enough experience with ChatGPT to believe that it can produce challenges suitable for my current skill level. I\u0026rsquo;ve added this to my list of coding things to try, so check back in a few days.\nOne thing of interest I did find was Project Euler. It\u0026rsquo;s a series of 904 (at last count) challenges, starting with basic and progressing to considerable difficulty. The problems are math-based, and although I have successfully completed the first eight challenges, I found that the limiting factor was my understanding of mathematical concepts and not my coding.\nThe Project Euler website is dated but serves its purpose. The advantage is there\u0026rsquo;s no language requirement. You can use any language you want to determine the answer to the problem. FreeCodeCamp.org has the first 480 lessons available on their platform in JavaScript. If that\u0026rsquo;s your language, you may find the interface on FreeCodeCamp.com more useful. As I\u0026rsquo;m using Python, I wrote my code in VSCode and then manually entered my answer on the Project Euler website. I\u0026rsquo;m enjoying this challenge very much, and it\u0026rsquo;s helping me to expand both my coding ability and mathematical skills.\nCoding Challenges Produce Results #So far, I\u0026rsquo;ve found this type of challenge the most productive. Not only do I need to learn the Python syntax necessary to provide the solution, but I also need to apply logic and problem-solving skills (and let\u0026rsquo;s not forget the math) to figure out what I need to do before I even attempt to write the code. Project Euler suggests starting with a pencil and paper until you have an understanding of the problem and an outline to solve the problem. That\u0026rsquo;s a great suggestion for any programming project.\nWe\u0026rsquo;ve only got 97 days to go\u0026hellip;\n","date":"10 November 2024","permalink":"/posts/day-3-the-value-of-coding-challenges/","section":"Posts","summary":"","title":"Day #3: The Value of Coding Challenges"},{"content":"The sheer amount of coding material on the Internet is overwhelming. It\u0026rsquo;s easy to get lost in what the community calls \u0026lsquo;Tutorial Hell.\u0026rsquo; Students get stuck in an endless process of watching tutorials on YouTube for hours on end, with no appreciable gain in skill.\nI\u0026rsquo;m not saying that it\u0026rsquo;s impossible to learn coding from watching videos, but it\u0026rsquo;s sort of like learning to ride a bike by reading a book about riding a bike. It can tell you all the theories and best practices, but until you get out on your bike and fall off a few times, you\u0026rsquo;ll never learn how to do it.\nCoding is the same. This isn\u0026rsquo;t to say coding tutorials have no value. So far in my short journey, I\u0026rsquo;ve found them to provide tremendous value when used in a specific way.\n\u0026lsquo;Copy-Coding\u0026rsquo; as a Discovery Tool #\u0026lsquo;Copy-coding\u0026rsquo; as I call it, is the process of following along with a tutorial and copying the code they write line by line until you end up with a completed project.\nI get two benefits from this process. First, I learn what to expect from the language. I don\u0026rsquo;t focus on the syntax and structure of the code. Rather, I try to focus on the idea behind the code. What is the programmer trying to accomplish? How does the language enable the solution?\nSecond, even though my focus isn\u0026rsquo;t on the syntax or structure, I can\u0026rsquo;t help but absorb the patterns. Certain structures start feeling natural even after only a few hours of coding. These are basic structures but essential to a fundamental understanding of the code.\nThe Real Trick to Learning a Skill #Learned knowledge is powerful, but it cannot compare to practical knowledge. Just like the best way to learn to ride a bike is to jump on one and give it a shot, the best way to learn coding is to jump in, sans tutorial, and just figure stuff out.\nIt\u0026rsquo;s not easy to sit down in front of a blank editor and just bang out some code, so I\u0026rsquo;ve found some structures I can use to help jumpstart the process.\nMy favourite so far is the courses on FreeCodeCamp.org. I know, that\u0026rsquo;s painfully obvious. The lessons are well-built and start with a series of instructions that build out a functional application from the ground up. There are elements of \u0026lsquo;copy-coding\u0026rsquo; in some of the steps, but more than a few required me to go look up a solution in the Python docs. That\u0026rsquo;s how to learn.\nHere\u0026rsquo;s an example of one of the lessons where I followed the instructions (and looked up a few things) to create a random password generator:\nimport secrets import string def generate_password(length=16384, nums=1, special_chars=1, uppercase=1, lowercase=1): # Define the possible characters for the password letters = string.ascii_letters digits = string.digits symbols = string.punctuation # Combine all characters all_characters = letters + digits + symbols while True: password = \u0026#39;\u0026#39; # Generate password for _ in range(length): password += secrets.choice(all_characters) constraints = [ (nums, r\u0026#39;\\d\u0026#39;), (special_chars, fr\u0026#39;[{symbols}]\u0026#39;), (uppercase, r\u0026#39;[A-Z]\u0026#39;), (lowercase, r\u0026#39;[a-z]\u0026#39;) ] # Check constraints if all( constraint \u0026lt;= len(re.findall(pattern, password)) for constraint, pattern in constraints ): break return password if __name__ == \u0026#39;__main__\u0026#39;: new_password = generate_password() print(\u0026#39;Generated password:\u0026#39;, new_password) It was fun to see this script crank out a 16,384-character random password. Too bad I can\u0026rsquo;t use it on my Netflix account!\nMy First Solo Flight #To drive the lesson even further, each module comes with a final project. You\u0026rsquo;re given criteria for a program, and you need to produce a solution entirely on your own that passes a series of pre-determined tests. So far, in my short 2-day journey, this was the most interesting thing I\u0026rsquo;ve found.\nThe first project was to create a Python script that would take a list of arithmetic functions and pretty-print them to the console. There was an added twist that if the function call was flagged \u0026lsquo;True\u0026rsquo; the output also had to include the result of the calculation.\nHere\u0026rsquo;s a link to my solution on my GitHub. It\u0026rsquo;s messy, but it works. It passed all the tests. I plan to revisit this challenge in a few months to see what the new solution looks like.\nUntil then, only 98 more days to go\u0026hellip;\n","date":"9 November 2024","permalink":"/posts/day-2-coding-tutorials-vs-actually-coding/","section":"Posts","summary":"","title":"Day #2: Coding Tutorials vs. Actually Coding"},{"content":"My goal is to become an expert programmer. I know it\u0026rsquo;ll take much more than 100 days, but you know what they say about a journey of 1000 miles. It starts with a single step.\nAs for my first step, I should decide on a language. I\u0026rsquo;m somewhat flexible on the choice. JavaSript and Python are the two clear contenders. They both have massive communities, so support is readily available. So are training resources. Every conceivable method of learning is available for both languages.\nI have a few projects in mind I\u0026rsquo;d like to develop. I feel JavaScript would be the best suited for those projects. Most are frontend apps, but past experience (mostly with WordPress blogs/themes) has taught me that I will spend too much time on pixel-perfecting and not enough on actually learning to code.\nShould I Start with JavaScript or Python? #I think I\u0026rsquo;ll start with Python. I know JS isn\u0026rsquo;t all front-end work, but most of the training resources I\u0026rsquo;ve found include HTML and CSS. That\u0026rsquo;s not what I\u0026rsquo;m looking for. Python feels like the better choice. It\u0026rsquo;s equally popular and ubiquitous, but the beginner training trends more towards a CLI-based approach, which will keep me away from the deeper rabbit hole I know I\u0026rsquo;ll fall into.\nI\u0026rsquo;ve dabbled in Python a little over my years in IT. I doubt I\u0026rsquo;ve written more than a few dozen lines of code. I looked at it for my chess engine project but dismissed it in favour of a lower-level language. As you\u0026rsquo;ll recall from yesterday\u0026rsquo;s post, my focus was on the engine and not on learning the language.\nNow, I want to learn to be an expert program and become completely fluent in my chosen language. I\u0026rsquo;ll start with Python and see where it goes. As an aside, given its popularity for machine learning and data science, it\u0026rsquo;s likely a road whose end I may never see. But that\u0026rsquo;s half the fun.\nHow I Plan to Structure My Learning #I plan to spend three hours each day learning my new craft. I\u0026rsquo;ve broken it up into two 90-minute sessions. One focused on coding along with training tutorials. The second focused on writing code on my own, likely in the form of challenges until I have an idea of some basic apps I\u0026rsquo;d like to write.\nFor instance, I\u0026rsquo;d like a script that runs every night on my computer and sweeps all the screenshots off my desktop into a folder or maybe the trash. I use screenshots (or snippets) a lot for my day job, and every few days I need to tidy up my desktop. Perhaps a script to automate the process would be an interesting project.\nIf I find myself with extra time throughout my day, I\u0026rsquo;ll spend a few minutes on a learning app like Brilliant. I love the gamified format. It works well for me with Duolingo and my Spanish lessons. I\u0026rsquo;ve also dabbled in German, Russian and French. I\u0026rsquo;ve just started with Brilliant. I haven\u0026rsquo;t decided if I want to spring for the full version. Any feedback from current users would be appreciated. I also tried Mimo, but I feel it\u0026rsquo;s just a limited version of Brilliant.\nLike any good plan, this one is likely to fall apart quickly. But then I\u0026rsquo;ll just re-adjust and keep moving forward.\nOnly 99 more days to go\u0026hellip;\n","date":"8 November 2024","permalink":"/posts/day-1-laying-the-groundwork/","section":"Posts","summary":"","title":"Day #1: Laying the Groundwork"},{"content":"Credit where credit is due. This idea came right from a Tech with Tim video on how to make money from coding. The suggestion was to do a 100-day challenge as the start of a personal brand. So here it is. I\u0026rsquo;m going to spend the next 100 days learning how to code. The results, both good and bad, will be posted here on my blog for everyone to see.\nA Brief History Lesson #First, we should establish a bit of history. I\u0026rsquo;m not new to programming, but I\u0026rsquo;m very rusty and inexperienced in modern coding languages and techniques. More than 20 years ago, I was employed for a period of time as a web developer, building sites with PHP and MySQL. I also built several Windows apps in Visual Basic. Life took me away from coding for many years.\nI re-discovered coding about a year ago after re-discovering chess. I\u0026rsquo;m fascinated by chess, but I was dealing with anxiety when playing real games. (Thanks GothamChess for normalizing that for us all) I turned to the idea of computer chess as a way to enjoy the game and not have to deal with the anxiety of playing against actual people. I played well against bots.\nI started poking around and rediscovering coding through various chess engine tutorials. I copy-coded a chess engine in C. I made several attempts to write an engine in Rust. I may revisit this one. After a few weeks, I found myself not interested in coding but only learning it as a means to an end.I wans\u0026rsquo;t interested in the coding. Coding is impossible to learn if it\u0026rsquo;s not something you\u0026rsquo;re passionate about.\nFortunately, I am passionate about learning, and even though my re-introduction to coding was put on the shelf, it\u0026rsquo;s been recently dusted off and I\u0026rsquo;m genuinely interested to see where it goes.\nHere We Go Again #The second (or third) bout with coding was ignited by a Dan Martell video. (Seriously, if you don\u0026rsquo;t know who this guy is, look him up). He has a popular YouTube channel and his content focuses on entrepreneurship, particularly around software development. In several videos (this one in particular) he lays out the steps he\u0026rsquo;d take if starting over. Step One is to learn a high-value skill. He lists five: coding, content creation, copywriting, project management and sales.\nAll of those I have done. Meaning I\u0026rsquo;ve been paid professionally for providing those services, but I\u0026rsquo;ve never been able to manifest one of them into a sustainable business. I\u0026rsquo;m not blaming them, but they never worked for me. Despite that, I knew that coding was not an option. Too hard. Too much to learn. Too many people doing it. Wasn\u0026rsquo;t for me.\nExcept it\u0026rsquo;s all I could think about for days after watching that video. I realized that my mistake was writing off that skill for no reason. I love to learn new things. Coding is endless. I enjoy building useful things. Coding is useful. My lifestyle prevents me from building physical things (more on that later), but I could satisfy my desire to construct by doing it digitally. Coding is a valuable life skill that I can teach to my children.\nCoding is Really Hard #Yes, coding is hard to learn. Programming is even harder (yes, they are different). But when faced with a choice between two paths, take the harder one. As the kids used to say, the juice is worth the squeeze.\nMy goal is to spend three hours every day learning to code. At the end of the day (hopefully) I\u0026rsquo;ll summarize the day\u0026rsquo;s progress in a blog post that I will post to my website. I\u0026rsquo;ll include code examples as written and after 100 days, we can revisit some of them and see how far I\u0026rsquo;ve progressed. I haven\u0026rsquo;t decided which other platforms I\u0026rsquo;ll share this journey on. As you\u0026rsquo;ll recall, content creation is not an enjoyable process for me. But then again, neither is copywriting, yet here we are.\nIn hindsight, I\u0026rsquo;m beginning to understand the key to that Dan Martell video is to not only pick a skill and become great at it but also develop the other four. If you want a job as a programmer, being a great coder is enough. If you want to build something amazing, you need to tell people about it (content creation), describe it in detail (copywriting), keep everything on track (project management), and market it to the world (selling).\nThis is going to be interesting\u0026hellip;\n","date":"7 November 2024","permalink":"/posts/day-0-a-brief-history-lesson/","section":"Posts","summary":"","title":"Day #0: A Brief History Lesson"},{"content":"","date":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories"}]